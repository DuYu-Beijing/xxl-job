XXL-Job源码阅读
一、阅读备注
0、读README.md没啥用，要读XXL-JOB官方文档.md，先让服务跑起来瞧瞧。

1、com.xxl.job.admin.service.XxlJobService 任务的增删改查
备注：增加任务接口里面有很多校验逻辑

2、com.xxl.job.admin.service.LoginService 登录校验
有数据库表存储注册过的信息

3、com.xxl.job.admin.controller 此路径下有很多controller，涉及注册登录、服务注册和自动发现、任务添加和编辑、日志

4、核心类：com.xxl.job.core.executor.XxlJobExecutor

5、服务器启动 + 无框架调用的流程
服务器启动：
启动类加载，扫描包，加载com.xxl.job.admin.core.conf.XxlJobAdminConfig
	配置类继承InitializingBean，属性填充后，调用 afterPropertiesSet() 函数，初始化 xxlJobScheduler
		com.xxl.job.admin.core.scheduler.XxlJobScheduler#init
		触发池（快、慢）开启
		注册观察线程开启
		注册失败观察线程开启
		任务完成线程开启
		日志线程开启
		定时任务执行线程开启 com.xxl.job.admin.core.thread.JobScheduleHelper#start


com.xxl.job.admin.core.thread.JobScheduleHelper 开启线程，从表中获取数据并执行Job，有预先读5秒，间隔小于5秒的设置闹钟
	com.xxl.job.admin.core.thread.JobTriggerPoolHelper#addTrigger 使用线程池，异步将执行的任务放到队列
	com.xxl.job.admin.core.thread.JobTriggerPoolHelper#trigger触发执行Job
		com.xxl.job.admin.core.trigger.XxlJobTrigger#trigger设置必要信息
		com.xxl.job.admin.core.trigger.XxlJobTrigger#processTrigger 判断是否分片，调用任务，记录日志
		com.xxl.job.admin.core.trigger.XxlJobTrigger#runExecutor
			com.xxl.job.core.biz.impl.ExecutorBizImpl#run 执行远程调用job，反射出IJobHandler实例
			com.xxl.job.core.executor.XxlJobExecutor#registJobThread 创建并开启Job线程，处理队列中的改类任务的Item	
				com.xxl.job.core.thread.JobThread#run 守护线程执行 triggerQueue中的任务，反射执行方法
				com.xxl.job.core.handler.IJobHandler#execute 最终通过反射执行目标方法
			将开始反射出IJobHandler实例，放入 triggerQueue 队列中
	下次触发时间小于5秒，放入定时器线程中触发，不再读DB
	启动定时器线程，处理间隔时间短的任务
	


客户端提交注册Job的main函数
	com.xxl.job.executor.sample.frameless.config.FrameLessXxlJobConfig#initXxlJobExecutor 初始化接入方信息
		com.xxl.job.core.executor.impl.XxlJobSimpleExecutor#start 初始化JobHandler方法仓库
			根据注解 @XXLJob 注解来注册JobHandler
		com.xxl.job.core.executor.XxlJobExecutor#start
			初始化日志路径
			初始化注册中心的列表，将接入地址和token传入
			初始化日志文件清理时长
			回调线程启动
			启动一个NIO服务EmbedServer（Netty）
				com.xxl.job.core.server.EmbedServer 开启守护线程，注册app
					com.xxl.job.core.thread.ExecutorRegistryThread#start 开启注册守护线程，每30秒注册一次
						com.xxl.job.core.biz.client.AdminBizClient#registry 注册客户端发送HTTP请求到中心服务
						服务端处理rest请求：
						com.xxl.job.admin.controller.JobApiController#api 接收处理请求
							com.xxl.job.admin.core.thread.JobRegistryHelper#registry 使用线程池异步处理请求
								保存到数据库，刷新注册信息


6、Spring启动入口：
启动类扫描并实例化Bean时，com.xxl.job.executor.core.config.XxlJobConfig#xxlJobExecutor，配置文件中的Bean对象xxlJobExecutor被实例化
com.xxl.job.core.executor.impl.XxlJobSpringExecutor
	XxlJobSpringExecutor 继承了 ApplicationContextAware，会在Bean实例化后调用aware
	初始化基于方法拦截的仓库
		通过查找 @XxlJob的注解，拉取被调用的方法列表
		注册jobHandlercom.xxl.job.core.executor.XxlJobExecutor#registJobHandler
		通过反射，将job执行方法放入 jobHandlerRepository仓库中
	初始化反射job实例的模式
	com.xxl.job.core.executor.XxlJobExecutor#start 和客户端一样的job执行器启动初始化
	
	
	
二、问题：
1、单元测试用例看起来是h2的，怎么会实际连我们本地数据库呢？com.xxl.job.admin.controller.JobInfoControllerTest
--->不是H2的数据库，是链接实际数据库的。目前的启动类是AbstractSpringMVCTest，上面注解是 @SpringBootTest，是实际数据库连接
2、单元测试用例怎样运行起来呢？
--->在数据库建立表之后，可以运行起来
3、向中心注册Handler时，会把handler的类或方法字节码传到注册中心么？不然怎么反射出类，反射执行方法呢？
远程调用服务倒是可行，RPC接口，知道地址，直接执行
--->调度器是本地的，中心只负责调度，收集日志
4、com.xxl.job.executor.sample.frameless.config.FrameLessXxlJobConfig#initXxlJobExecutor 这个简单调用，实际部署服务后，通过RPC调用吧？
5、job执行回调，是/run的http接口，不是函数方法？
	是开启了netty服务，并加载了接口么？等/run调用netty接口时，就执行该函数？说明netty也有jvm么？
	---> 中心分机思想，执行/run是分机（客户端）向注册中心发送请求，注册中心通过EmbedHttpServerHandler类处理http请求，执行ExecutorBizImpl里run方法，反射实现函数调用


三、观看其他组员学习历程有感
1、更新数据库的写法，现update后save
2、方法入参增加传入自定义的默认值，也有优势
3、线程池参数选定，各参数意义，拒绝策略，JDK的源码
4、分布式锁的方式，优缺点
5、aware的种类和用法，spring源码
6、路由，多服务启动
7、饿汉模式：使用之前，就已经new好了这个类
懒汉模式：--
8、守护线程和普通线程的区别？
9、调度 -- 执行器执行 -- 是否成功失败 -- 异步通知调度 -- 调度重复或者超时处理
10、日志写入队列的目的？量大？批量？阻塞耗时？


四、细读
1、无框架执行器启动注册Job
初始化配置信息
初始化JobHandler仓库，将注解标识的Job方法放到jobHandlerRepository
	初始化日志路径
		默认/data/applogs/xxl-job/jobhandler路径
		自定义的路径没校验并创建
	初始化执行器，负责本地回调、注册、注销
		通过注册地址，可以配置多个
	日志文件滚动
		开启守护线程，根据配置的保留天数，递归删除逾期日志文件
		线程休眠一天
	初始化回调线程
		启动守护线程，处理回调队列里面信息
			com.xxl.job.core.thread.TriggerCallbackThread#doCallback
				执行器发送http请求到Netty
				注册中心处理http请求
					com.xxl.job.admin.core.thread.JobCompleteHelper#callback()
						回调线程池执行com.xxl.job.admin.core.thread.JobCompleteHelper#callback()
				toStop暂停线程时，最后一次日志也会执行
				打印callbackLog，日志在执行器本地
				如果http请求无响应，回调任务被写入重试文件中
		启动守护线程，处理重试回调任务
	初始化Netty服务		
		启动守护线程，绑定端口和地址，启动Netty服务
			创建执行器线程池
			创建Netty服务，wait util stop
			中间调用注册执行器
				com.xxl.job.core.thread.ExecutorRegistryThread#start启动注册循环线程，循环间隔为心跳30秒
					执行器发送注册http请求
					注册中心处理http请求，异步将注册信息更新到表里 xxl_job_registry
				线程中，循环注册结束后，调用注销接口
					执行器发送注册http请求
					注册中心处理http请求，异步将注销信息更新到表里 xxl_job_registry，使用delete直接删除的
				
2、注册中心启动
com.xxl.job.admin.core.conf.XxlJobAdminConfig#afterPropertiesSet 实例化初始化后被调用
	com.xxl.job.admin.core.scheduler.XxlJobScheduler#init 初始化Job规划器
		1、国际化信息配置
			Spring加载初始化 com.xxl.job.admin.core.conf.XxlJobAdminConfig#i18n 值为简体中文
			message_zh_CN.properties 加载配置此文件的属性
			修改本地阻塞枚举值枚举值ExecutorBlockStrategyEnum为单机串行、丢弃后续调度、覆盖之前调度
		2、注册中心触发器线程池开启
			初始化快慢两个线程池，用来触发job
		3、job注册开启
			初始化注册或注销线程池
			开启注册监听线程，守护线程，心跳30秒一循环
				获取自动注册的job组，xxl_job_group
				清理心跳结束的注册，xxl_job_registry，连续>3个心跳周期丢失
				刷新心跳周期在3个内的状态
					获取注册地址
				将注册地址更新到job组属性中，就是将 xxl_job_registry 地址同步到 xxl_job_group，因为注册表会有心跳注册一直更新
		4、job失败监听开启
			开启监听守护线程，10秒循环一次
				从表 xxl_job_log 中查询失败日志
				锁定日志
				重试触发，并更新日志表
				告警，发送邮件，修改表xxl_job_log中的告警状态
		5、job完成开启
			初始化回调线程池
			Job丢失监控线程开启，守护线程，60秒一循环
				从日志表中查找更新时间超过10分钟，运行中的日志
					结束job，com.xxl.job.admin.core.complete.XxlJobCompleter#finishJob
						如果调度成功，则直接触发其子job
					更新日志信息
		6、job日志报告开启
			开启守护线程，循环时间1分钟
				最近三天日志表中的每天日志量，调度总量，调度成功量
				更新到xxl_job_log_report 报告表中
				查询过期日志，天数是执行器传过来的参数
				将日志删除
		7、job循环调度开启

3、路由策略
	com.xxl.job.admin.core.route.ExecutorRouter的子类，策略模式
4、日志队列
	XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(jobLog);没有队列呀？？？
5、实现单机串行
	JobScheduleHelper 循环查阅待执行的jobInfo时，使用DB的分布式锁
	每次只会有一个注册中心实例拿到DB锁，该实例会扫描表中所有待执行的job信息

五、疑问
1、回调执行callBack函数，com.xxl.job.admin.core.thread.JobCompleteHelper#callback()，是注册中心执行还是执行器执行？xxl_job_log表
---> 注册中心执行，AdminBizClient 与 ExecutorBizClient 的区别解释了这个。
2、清理死亡注册job后，还要刷新？不是已经被清理了么？JobRegistryHelper
---> 小于死亡时间段的输入死亡job，大于死亡时间段小于当前的是存活线程


六、交流分享
1、hash强一致性
2、用户设置加权，如何实现加权轮询
3、通过LinkedHashMap实现常用的和不常用的元素排序与获取
看一下使用频率最大和最小，他们实现不一样的
4、